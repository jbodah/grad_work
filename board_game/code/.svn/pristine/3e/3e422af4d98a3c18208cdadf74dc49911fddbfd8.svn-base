<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Talker.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">Merged (Apr 28, 2012 2:01:54 PM)</a> &gt; <a href="../../index.html" class="el_group">Framework</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.html" class="el_package">ks.client.ipc</a> &gt; <span class="el_source">Talker.java</span></div><h1>Talker.java</h1><pre class="source lang-java linenums">package ks.client.ipc;


/**
 * The Talker class is responsible for all communication with the server.
 * &lt;p&gt;
 * Once the communication to the server's port is set up, Talker issues
 * a &quot;login&quot; command. Thereafter, all commands delivered to talker are
 * simply sent along to the server.
 * &lt;p&gt;
 * Note that the Talker does not actually read this response, since it is
 * responsible only for speaking to the server.
 * &lt;p&gt;
 * After a successful login, all communication through Talker is using XML
 * messages.
 * 
 * @author George T. Heineman (heineman@cs.wpi.edu)
 */
import java.io.*;

import org.w3c.dom.Document;

import ks.framework.common.Message;
import ks.framework.common.network.CommunicationAgent;
import ks.framework.common.network.SimpleClientConnection;

/**
 * Class responsible for sending command objects to the server. 
 */
<span class="fc" id="L30">class Talker implements Runnable {</span>
	
	/** Debugging. */
<span class="fc" id="L33">	static boolean DEBUG = true;</span>

	/** Connection to server. */
	protected SimpleClientConnection me;

	/** Start with accepted default port address. */
<span class="fc" id="L39">	protected int port = 7878;</span>

	/** Agent awaiting connection status. */
	private Client connector;

	/** Executing within our own thread. */
<span class="fc" id="L45">	private Thread thread = null;</span>

	/** Target host we are trying to connect with. */
<span class="fc" id="L48">	private String host = null;</span>
	
	/** name of user. */
<span class="fc" id="L51">	private String who = null;</span>

	/** Password of user. */
<span class="fc" id="L54">	private String password = null;</span>

	/** A self-registered interaction? */
<span class="fc" id="L57">	private boolean selfRegister = false;</span>
	
	/** Are we connected to the server? */
	protected boolean connected;

	/** Need to keep track of who responds to messages from the server. */
<span class="fc" id="L63">	public Talker(Client parent) {</span>
<span class="fc" id="L64">		this.connector = parent;</span>
<span class="fc" id="L65">	}</span>

	// Thread is told to disconnect
	public void disconnect() {
<span class="fc" id="L69">		notifyDisconnect();</span>

		// we are no longer connected.
<span class="fc" id="L72">		connected = false;</span>
<span class="fc" id="L73">	}</span>
	/**
	 * Initiate communication with server.
	 * 
	 * First one to send anything to the server. The first command sent by the 
	 * client is a Login. Note that we cannot wait for the Message response. That
	 * comes through its own channel.
	 */
	private boolean doInitiate(String host, String who, String password, boolean selfRegister) {
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">		if (DEBUG) System.err.println(&quot;Connecting to &quot; + host + &quot;:&quot; + port + &quot; [&quot; + who + &quot;]&quot;);</span>

		try {
<span class="nc" id="L85">			me = new SimpleClientConnection(host, port);</span>
			
<span class="fc" id="L87">		} catch (IOException ioe) {</span>
<span class="fc" id="L88">			System.err.println(&quot;Talker::doInitiate(). Could not create a network connection:&quot; + ioe.toString());</span>
<span class="fc" id="L89">			return false;</span>
		}

<span class="nc bnc" id="L92" title="All 4 branches missed.">		if (me == null || !me.isConnected()) {</span>
<span class="nc" id="L93">			System.err.println(&quot;Talker::doInitiate(). Could not connect to '&quot; + host + &quot;:&quot; + port + &quot;'.&quot;);</span>
<span class="nc" id="L94">			return false;</span>
		}
		
<span class="nc bnc" id="L97" title="All 2 branches missed.">		if (DEBUG) System.err.println(&quot;trying to connect.&quot;);</span>

		// send login command.
<span class="nc" id="L100">		String player = &quot;player ='&quot; + who + &quot;'&quot;;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">		if (who == null) {</span>
<span class="nc" id="L102">			player = &quot;&quot;;</span>
		}
		
		
<span class="nc" id="L106">		String login = Message.requestHeader() +</span>
<span class="nc" id="L107">					   &quot;   &lt;login &quot; + player + &quot; password='&quot; + password + &quot;'&quot; +</span>
<span class="nc" id="L108">					   &quot; self-register='&quot; + selfRegister + &quot;' &quot; +</span>
<span class="nc" id="L109">		               &quot;/&gt;&lt;/request&gt;&quot;;</span>
			
<span class="nc" id="L111">		Document d = Message.construct(login);</span>
<span class="nc" id="L112">		Message m = new Message(d);</span>

<span class="nc bnc" id="L114" title="All 2 branches missed.">		if (!writeObject (m)) {</span>
<span class="nc" id="L115">			System.err.println(&quot;Talker::doInitiate(). Could not connect to '&quot; + host + &quot;:&quot; + port + &quot;'.&quot;);</span>
<span class="nc" id="L116">			return false;</span>
		}
		
		// looks good.
<span class="nc" id="L120">		return true;</span>
	}


	/**
	 * Determine if we are connected. Creation date: (9/30/01 12:10:53 AM)
	 * 
	 * @return boolean
	 */
	public boolean isConnected() {
<span class="nc" id="L130">		return connected;</span>
	}

	private synchronized void notifyDisconnect() {
<span class="fc" id="L134">		notify();</span>
<span class="fc" id="L135">	}</span>

	/**
	 * Initiate server connection and wait until we are disconnected.
	 * 
	 * If fail to initiate, disconnect and terminate thread.
	 */
	public void run() {
		try {
			// do the initiate here, in separate thread
<span class="nc bnc" id="L145" title="All 2 branches missed.">			if (!doInitiate(host, who, password, selfRegister)) {</span>
<span class="nc" id="L146">				System.err.println(&quot;Talker::run(). Unable to connect within Talker.&quot;);</span>
				// actually close down socket
<span class="nc" id="L148">				connector.connected(false);</span>
<span class="nc" id="L149">				me.disconnect();</span>
<span class="nc" id="L150">				return;</span>
			}

<span class="fc" id="L153">		} catch (Exception e) {</span>
<span class="fc" id="L154">			System.err.println(&quot;Talker::run(). Unexpected exception in run:&quot; + e.toString());</span>
<span class="fc" id="L155">			connector.connected(false);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">			if (me != null) {</span>
<span class="nc" id="L157">				me.disconnect();</span>
			}
<span class="fc" id="L159">			return;</span>
		}

		// we are connected...
<span class="nc" id="L163">		connector.connected(true);</span>
<span class="nc" id="L164">		setConnected(true);</span>

		// At this point, Talker is done, but we need to keep the connection
		// open. So we wait until we get a request to disconnect
<span class="nc" id="L168">		waitForDisconnect();</span>

		// actually close down socket
<span class="nc" id="L171">		connector.connected(false);</span>
<span class="nc" id="L172">		me.disconnect();</span>
<span class="nc" id="L173">	}</span>

	/**
	 * Set our connection state. Creation date: (9/30/01 12:10:53 AM)
	 * 
	 * @param newConnected
	 *            boolean
	 */
	public void setConnected(boolean newConnected) {
<span class="nc" id="L182">		connected = newConnected;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (!connected) {</span>
<span class="nc" id="L184">			disconnect();</span>
		}
<span class="nc" id="L186">	}</span>

	/**
	 * Talker needs these three values to begin communicating with the server.
	 */
	public void setvalues(String host, int port, String who, String password, boolean selfRegister) {
<span class="fc" id="L192">		this.host = host;</span>
<span class="fc" id="L193">		this.port = port;</span>
<span class="fc" id="L194">		this.who = who;</span>
<span class="fc" id="L195">		this.password = password;</span>
<span class="fc" id="L196">		this.selfRegister = selfRegister;</span>
<span class="fc" id="L197">	}</span>

	/**
	 * Start the main thread running.
	 */
	public void start() {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">		if (thread == null) {</span>
<span class="fc" id="L204">			thread = new Thread(this);</span>
<span class="fc" id="L205">			thread.start();</span>
		}
<span class="fc" id="L207">	}</span>

	private synchronized void waitForDisconnect() {
		try {
<span class="nc" id="L211">			wait();</span>
<span class="nc" id="L212">		} catch (InterruptedException ie) {</span>
		}
<span class="nc" id="L214">	}</span>

	/**
	 * Send command to the server.
	 * 
	 * @param msg   Command to be sent.
	 */
	public boolean writeObject(Message msg) {
<span class="nc" id="L222">		CommunicationAgent agent = me.getAgent();</span>
<span class="nc" id="L223">		return agent.writeObject (msg);</span>
	}

	/** Expose the CommunicationAgent associated with this Talker thread. */
	public CommunicationAgent getAgent() {
<span class="nc" id="L228">		return me.getAgent();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.6.201201232323</span>Merged (Apr 28, 2012 2:01:54 PM)</div></body></html>